import { deepEqual, strictEqual, throws } from "node:assert"
import { describe, it } from "node:test"
import { hexToBytes, makeByteStream } from "@helios-lang/codec-utils"
import { encodeInt } from "./int.js"
import { decodeString, encodeString, isString } from "./string.js"

describe(isString.name, () => {
    it("returns true for [0x60]", () => {
        strictEqual(isString([0x60]), true)
    })

    it("returns false for [0]", () => {
        strictEqual(isString([0]), false)
    })

    it("fails for []", () => {
        throws(() => isString([]))
    })

    it("doesn't change stream pos", () => {
        const stream = makeByteStream([0x60])

        strictEqual(isString(stream), true)
        strictEqual(stream.pos, 0)
    })

    it("doesn't change stream pos if not a string", () => {
        const stream = makeByteStream(encodeInt(0))

        strictEqual(isString(stream), false)
        strictEqual(stream.pos, 0)
    })
})

describe(decodeString.name, () => {
    it('returns "" for [0x60]', () => {
        strictEqual(decodeString([0x60]), "")
    })

    it('returns "a" for [0x61, 0x61]', () => {
        strictEqual(decodeString([0x61, 0x61]), "a")
    })

    it('returns "IETF" for #6449455446', () => {
        strictEqual(decodeString(hexToBytes("6449455446")), "IETF")
    })

    it('returns ""\\" for #62225c', () => {
        strictEqual(decodeString(hexToBytes("62225c")), '"\\')
    })

    it('returns "Ã¼" for #62c3bc', () => {
        strictEqual(decodeString(hexToBytes("62c3bc")), "Ã¼")
    })

    it('returns "æ°´" for #63e6b0b4', () => {
        strictEqual(decodeString(hexToBytes("63e6b0b4")), "æ°´")
    })

    it('returns "ð…‘" for #64f0908591', () => {
        strictEqual(decodeString(hexToBytes("64f0908591")), "ð…‘")
    })

    it("fails for []", () => {
        throws(() => decodeString([]))
    })

    it("fails for [0]", () => {
        throws(() => decodeString([0]))
    })
})

describe(encodeString.name, () => {
    it('returns [0x60] for ""', () => {
        deepEqual(encodeString(""), [0x60])
    })

    it('returns [0x61, 0x61] for "a"', () => {
        deepEqual(encodeString("a"), [0x61, 0x61])
    })

    it('returns #6449455446 for "IETF"', () => {
        deepEqual(encodeString("IETF"), hexToBytes("6449455446"))
    })
})

describe(`${encodeString.name}/${decodeString.name} roundtrip`, () => {
    const testVector = [
        "å¤©",
        "åœ°çŽ„",
        "é»ƒå®‡å®™",
        "æ´ªè’ã€‚è“‹",
        "æ­¤èº«é«®å››å¤§",
        "äº”å¸¸ã€‚éƒ½é‚‘è¯",
        "å¤æ±è¥¿äºŒäº¬ã€‚æ²»",
        "æœ¬æ–¼è¾²å‹™èŒ²ç¨¼ç©¡ã€‚",
        "è€½è®€çŽ©å¸‚å¯“ç›®å›Šç®±ã€‚",
        "å¸ƒå°„åƒšä¸¸åµ‡ç´é˜®å˜¯ã€‚æ—¥",
        "æœˆç›ˆæ˜ƒè¾°å®¿åˆ—å¼µã€‚æ­æƒŸéž ",
        "é¤Šè±ˆæ•¢æ¯€å‚·ã€‚èƒŒé‚™é¢æ´›æµ®æ¸­",
        "æ“šæ¶‡ã€‚ä¿¶è¼‰å—ç•æˆ‘è—é»ç¨·ã€‚æ˜“",
        "è¼¶æ”¸ç•å±¬è€³åž£ç‰†ã€‚æ¬ç­†å€«ç´™éˆžå·§",
        "ä»»é‡£ã€‚å¯’ä¾†æš‘å¾€ï¼Œç§‹æ”¶å†¬è—ã€‚å¥³æ…•",
        "è²žçµœç”·æ•ˆæ‰è‰¯ã€‚å®®æ®¿ç›¤éƒæ¨“è§€é£›é©šã€‚ç¨…",
        "ç†Ÿè²¢æ–°å‹¸è³žé»œé™Ÿã€‚å…·è†³é¤é£¯é©å£å……è…¸ã€‚é‡‹",
        "ç´›åˆ©ä¿—ç«çš†ä½³å¦™ã€‚é–é¤˜æˆæ­²å¾‹å‘‚èª¿é™½ã€‚çŸ¥éŽ",
        "å¿…æ”¹å¾—èƒ½èŽ«å¿˜ã€‚åœ–å¯«ç¦½ç¸ç•«å½©ä»™éˆã€‚å­Ÿè»»æ•¦ç´ ",
        "å²é­šç§‰ç›´ã€‚é£½é£«çƒ¹å®°é£¢åŽ­ç³Ÿç³ ã€‚æ¯›æ–½æ·‘å§¿å·¥é¡°å¦",
        "ç¬‘ã€‚é›²é¨°è‡´é›¨éœ²çµç‚ºéœœã€‚ç½”è«‡å½¼çŸ­é¡æƒå·±é•·ã€‚ä¸™èˆ",
        "å‚å•Ÿç”²å¸³å°æ¥¹ã€‚åº¶å¹¾ä¸­åº¸å‹žè¬™è¬¹æ••ã€‚è¦ªæˆšæ•…èˆŠè€å°‘ç•°",
        "ç³§ã€‚å¹´çŸ¢æ¯å‚¬æ›¦æš‰æœ—æ›œã€‚é‡‘ç”Ÿéº—æ°´çŽ‰å‡ºå´‘å²¡ã€‚ä¿¡ä½¿å¯è¦†",
        "å™¨æ¬²é›£é‡ã€‚è‚†ç­µè¨­å¸­é¼“ç‘Ÿå¹ç¬™ã€‚è†éŸ³å¯Ÿç†é‘’è²Œè¾¨è‰²ã€‚å¦¾å¾¡",
        "ç¸¾ç´¡ä¾å·¾å¸·æˆ¿ã€‚ç’¿ç’£æ‡¸æ–¡æ™¦é­„ç’°ç…§ã€‚åŠè™Ÿå·¨é—•ç ç¨±å¤œå…‰ã€‚å¢¨",
        "æ‚²çµ²æŸ“è©©è®šç¾”ç¾Šã€‚å‡éšŽç´é™›å¼è½‰ç–‘æ˜Ÿã€‚è²½åŽ¥å˜‰çŒ·å‹‰å…¶ç¥—æ¤ã€‚ç´ˆ",
        "æ‰‡åœ“æ½”éŠ€ç‡­ç…’ç…Œã€‚æŒ‡è–ªä¿®ç¥œæ°¸ç¶å‰åŠ­ã€‚æžœçæŽæŸ°èœé‡èŠ¥è–‘ã€‚æ™¯è¡Œ",
        "ç¶­è³¢å…‹å¿µä½œè–ã€‚å³é€šå»£å…§å·¦é”æ‰¿æ˜Žã€‚çœèº¬è­èª¡å¯µå¢žæŠ—æ¥µã€‚æ™çœ å¤•å¯",
        "è—ç­è±¡åºŠã€‚çŸ©æ­¥å¼•é ˜ä¿¯ä»°å»Šå»Ÿã€‚æµ·é¹¹æ²³æ·¡ï¼Œé±—æ½›ç¾½ç¿”ã€‚å¾·å»ºåç«‹å½¢ç«¯",
        "è¡¨æ­£ã€‚æ—¢é›†å¢³å…¸äº¦èšç¾¤è‹±ã€‚æ®†è¾±è¿‘æ¥æž—çš‹å¹¸å³ã€‚å¼¦æ­Œé…’å®´æŽ¥æ¯èˆ‰è§´ã€‚æŸ",
        "å¸¶çŸœåº„å¾˜å¾Šçž»çœºã€‚ç©ºè°·å‚³è²è™›å ‚ç¿’è½ã€‚æœç¨¿é¾éš¸æ¼†æ›¸å£ç¶“ã€‚å…©ç–è¦‹æ©Ÿè§£çµ„",
        "èª°é€¼ã€‚çŸ¯æ‰‹é “è¶³ï¼Œæ‚…è±«ä¸”åº·ã€‚å­¤é™‹å¯¡èžï¼Œæ„šè’™ç­‰èªšã€‚é¾å¸«ç«å¸ï¼Œé³¥å®˜äººçš‡ã€‚",
        " ç¦å› æƒ¡ç©ï¼Œç¦ç·£å–„æ…¶ã€‚ 	åºœç¾…å°‡ç›¸ï¼Œè·¯ä¿ æ§å¿ã€‚ 	ç´¢å±…é–’è™•ï¼Œæ²‰é»˜å¯‚å¯¥ã€‚",
        "å«¡å¾Œå—£çºŒï¼Œç¥­ç¥€çƒå˜—ã€‚ 	è¬‚èªžåŠ©è€…ï¼Œç„‰å“‰ä¹Žä¹Ÿã€‚       å§‹è£½æ–‡å­—ï¼Œä¹ƒæœè¡£è£³",
        "å°ºç’§éžå¯¶ï¼Œå¯¸é™°æ˜¯ç«¶ã€‚ 	æˆ¶å°å…«ç¸£ï¼Œå®¶çµ¦åƒå…µã€‚ 	æ±‚å¤å°‹è«–ï¼Œæ•£æ…®é€é™ã€‚ç¨½é¡™",
        "å†æ‹œï¼Œæ‚šæ‡¼ææƒ¶ã€‚ 	       æŽ¨ä½è®“åœ‹ï¼Œæœ‰è™žé™¶å”ã€‚ 	è³‡çˆ¶äº‹å›ï¼Œæ›°åš´èˆ‡æ•¬ã€‚",
        " 	é«˜å† é™ªè¼¦ï¼Œé©…è½‚æŒ¯çº“ã€‚ 	æ¬£å¥ç´¯é£ï¼Œæ…¼è¬æ­¡æ‹›ã€‚ 	ç®‹ç‰’ç°¡è¦ï¼Œé¡§ç­”å¯©è©³ã€‚  ",
        "å¼”æ°‘ä¼ç½ªï¼Œå‘¨ç™¼æ®·æ¹¯ã€‚ 	å­ç•¶ç«­åŠ›ï¼Œå¿ å‰‡ç›¡å‘½ã€‚ 	ä¸–ç¥¿ä¾ˆå¯Œï¼Œè»Šé§•è‚¥è¼•ã€‚ 	æ¸ è·",
        "çš„æ­·ï¼Œåœ’èŽ½æŠ½æ¢ã€‚ 	éª¸åž¢æƒ³æµ´ï¼ŒåŸ·ç†±é¡˜æ¶¼ã€‚ 	        åæœå•é“ï¼Œåž‚æ‹±å¹³ç« ã€‚ 	",
        "è‡¨æ·±å±¥è–„ï¼Œå¤™èˆˆæº«å‡Šã€‚ 	ç­–åŠŸèŒ‚å¯¦ï¼Œå‹’ç¢‘åˆ»éŠ˜ã€‚ 	æž‡æ·æ™šç¿ ï¼Œæ¢§æ¡èš¤å‡‹ã€‚ 	é©¢é¨¾çŠ¢ç‰¹",
        "ï¼Œé§­èºè¶…é©¤ã€‚ 	æ„›è‚²é»Žé¦–ï¼Œè‡£ä¼æˆŽç¾Œã€‚ 	ä¼¼è˜­æ–¯é¦¨ï¼Œå¦‚æ¾ä¹‹ç››ã€‚ 	ç£»æºªä¼Šå°¹ï¼Œä½æ™‚é˜¿è¡¡",
        "ã€‚ 	é™³æ ¹å§”ç¿³ï¼Œè½è‘‰é£„æ–ã€‚ 	èª…æ–¬è³Šç›œï¼Œæ•ç²å›äº¡ã€‚ 	      éé‚‡ä¸€é«”ï¼ŒçŽ‡è³“æ­¸çŽ‹ã€‚",
        " 	å·æµä¸æ¯ï¼Œæ·µæ¾„å–æ˜ ã€‚ 	å¥„å®…æ›²é˜œï¼Œå¾®æ—¦å­°ç‡Ÿã€‚ 	éŠéµ¾ç¨é‹ï¼Œå‡Œæ‘©çµ³éœ„ã€‚ 		   ",
        "    é³´é³³åœ¨ç«¹ï¼Œç™½é§’é£Ÿå ´ã€‚ 	å®¹æ­¢è‹¥æ€ï¼Œè¨€è¾­å®‰å®šã€‚ 	æ¡“å…¬åŒ¡åˆï¼Œæ¿Ÿå¼±æ‰¶å‚¾ã€‚    åŒ–è¢«è‰æœ¨ï¼Œ",
        "è³´åŠè¬æ–¹ã€‚ 	ç¯¤åˆèª ç¾Žï¼Œæ…Žçµ‚å®œä»¤ã€‚ 	ç¶ºå›žæ¼¢æƒ ï¼Œèªªæ„Ÿæ­¦ä¸ã€‚æ¦®æ¥­æ‰€åŸºï¼Œè—‰ç”šç„¡ç«Ÿã€‚ 	ä¿Šä¹‚",
        "å¯†å‹¿ï¼Œå¤šå£«å¯”å¯§ã€‚ 			        å­¸å„ªç™»ä»•ï¼Œæ”è·å¾žæ”¿ã€‚ 	æ™‰æ¥šæ›´éœ¸ï¼Œè¶™é­å›°æ©«ã€‚     å­˜",
        "ä»¥ç”˜æ£ ï¼ŒåŽ»è€Œç›Šè© ã€‚ 	å‡é€”æ»…è™¢ï¼Œè¸åœŸæœƒç›Ÿã€‚ 			         æ¨‚æ®Šè²´è³¤ï¼Œç¦®åˆ¥å°Šå‘ã€‚ 	",
        "ä½•éµç´„æ³•ï¼ŒéŸ“å¼Šç…©åˆ‘ã€‚ 			          ä¸Šå’Œä¸‹ç¦ï¼Œå¤«å”±å©¦éš¨ã€‚ 	èµ·ç¿¦é —ç‰§ï¼Œç”¨è»æœ€ç²¾ã€‚ 	  ",
        "           å¤–å—å‚…è¨“ï¼Œå…¥å¥‰æ¯å„€ã€‚ 	å®£å¨æ²™æ¼ ï¼Œé¦³è­½ä¸¹é’ã€‚ 			          è«¸å§‘ä¼¯å”ï¼ŒçŒ¶",
        "å­æ¯”å…’ã€‚ 	ä¹å·žç¦¹è·¡ï¼Œç™¾éƒ¡ç§¦å¹¶ã€‚ 			          å­”æ‡·å…„å¼Ÿï¼ŒåŒæ°£é€£æžã€‚ 	å²³å®—æ³°å²±ï¼Œç¦ªä¸»äº‘äº­",
        "ã€‚ 			         äº¤å‹æŠ•åˆ†ï¼Œåˆ‡ç£¨ç®´è¦ã€‚ 	é›é–€ç´«å¡žï¼Œé›žç”°èµ¤åŸŽã€‚          ä»æ…ˆéš±æƒ»ï¼Œé€ æ¬¡å¼—",
        "é›¢ã€‚ 	æ˜†æ± ç¢£çŸ³ï¼Œé‰…é‡Žæ´žåº­ã€‚ 			       ç¯€ç¾©å»‰é€€ï¼Œé¡›æ²›åŒªè™§ã€‚ 	æ› é ç¶¿é‚ˆï¼Œå²©å²«æ³å†¥ã€‚    ",
        "æ€§éœæƒ…é€¸ï¼Œå¿ƒå‹•ç¥žç–²ã€‚            å®ˆçœŸå¿—æ»¿ï¼Œé€ç‰©æ„ç§»ã€‚                       å …æŒé›…æ“ï¼Œå¥½çˆµè‡ªç¸»ã€‚"
    ]

    testVector.forEach((v, i) => {
        const split = i % 2 == 0

        it(`ok for "${v}" with split=${split}`, () => {
            strictEqual(decodeString(encodeString(v, split)), v)
        })
    })
})
